# HW 1: Finding Submarines
# Author: Jensen DeGrande
# Computational Methods for Data Analysis, AMATH 582
# Date of creation: 01/24/22
# Last edited: 01/28/22

# Problem/Purpose: Your goal is to locate a submarine in the Puget sound using noisy acoustic data. You must detect
# the frequency that the submarine emits as it is moving.

# Data: Broad spectrum recording of acoustics data obtained over 24 hours in half-hour increments is available (
# subdata.npy). This file contains a matrix with 49 columns of data corresponding to the measurements of acoustic
# pressure taken over 24 hours. These measurements are 3D and taken on a uniform grid size 64x64x64

########################################################################################################################
# import necessary packages for math and simple plots
import numpy as np
import matplotlib.pyplot as plt

# import libraries for plotting isosurfaces
import plotly
import plotly.graph_objs as go
# utility for clearing output of cell as loop runs in notebook
from IPython.display import clear_output
# import plotly.io as pio
# pio.renderers.default = "firefox"

# ############### Setting up the data
# set the data path
dataPath = '/Users/jensen/Library/Mobile Documents/com~apple~CloudDocs/AMATH582/Homework/HW1/subdata.npy'
# load the data
data = np.load(dataPath)  # huge matrix of size 262144 x 49 (columns contain flattened 3d matrix of size 64x64x64)

# so now we need to reshape the data from the 262144 x 49 into a 64x64x64 matrix... bc 262144 = 64^3

# Note: The fourier transform shifts from time domain to freq domain so that you can pick out certain frequencies


# code from HW1_Helper.ipynb on Canvas for plotting purposes (establish all the grid spaces)
L = 10  # length of spatial domain (cube of side L = 2*10)
N_grid = 64  # number of grid points/Fourier modes in each direction (64x64x64)
xx = np.linspace(-L, L, N_grid + 1)  # spatial grid in x dir
x = xx[0:N_grid]  # x,y,z is the spatial domain!
y = x  # same grid in y,z direction
z = x
K_grid = (2 * np.pi / (2 * L)) * np.linspace(-N_grid / 2, N_grid / 2 - 1, N_grid)  # frequency grid for one coordinate
xv, yv, zv = np.meshgrid(x, y, z)  # generate 3D meshgrid for plotting
xf, yf, zf = np.meshgrid(np.arange(0, 64), np.arange(0, 64), np.arange(0, 64))  # 0-64 grid space (plotting purposes)
kx, ky, kz = np.meshgrid(K_grid, K_grid, K_grid)  # K_grid = all the k values in order

# So let's try Task 1:
# 1. Loop over each column
# 2. Reshape it to a 64x64x64
# 3. Take the 3D fft --- fft_signal = np.fft.fftn(signal)
# 4. Shift the signal and add it to a sum variable so we can average it
# 5. (outside of loop) - Take the average by dividing by 49
#       - We want to average it b/c it will clean up some of the noise (hint)
# 6. Find the maximum index - this is where the frequency/power of signal is largest
#       - there will be TWO bc there is a reflection (so it's the same signal, just reflected)
#       - not necessary to include both, but it will give a cleaner path
# 7. Plot the data
# 8. By visual inspection, determine the frequency signature (+/- 5.3, +/- 2.2, +/-6.9) generated by the submarine

# let's plot the original data
sum_fft_signal = np.zeros((N_grid, N_grid, N_grid))  # allocate space for storing the sum

# This creates a loop that will loop through all 49 columns of the original data array, each column
for j in range(0, 49, 1):
    signal = np.reshape(data[:, j], (N_grid, N_grid, N_grid))  # each cube (signal[n]) is a snapshot of volume in time
    # normal_sig_abs = np.abs(signal) / np.abs(signal).max()  # normalize for visualization?
    fft_signal = np.fft.fftn(signal)  # this creates the 3D fourier domain
    fft_signal_shifted = np.fft.fftshift(fft_signal)
    sum_fft_signal = sum_fft_signal + fft_signal_shifted  # sum it inside the for loop so we can average it easily

# AVERAGE: element-wise averaging of the 49 matrices (num of time steps)
fft_average = np.real(np.abs(sum_fft_signal / 49))
# find the maximum value using np.partition to get the max and second max - we know there are two points that are just
# reflections over an axis, but we want both
firstMax = np.partition(fft_average.flatten(), -1)[-1]  # 89.89652346622289
secondMax = np.partition(fft_average.flatten(), -2)[-2]

fft_max_location1 = np.where(fft_average == firstMax)  # np.where defaults to Y,X,Z (column, row)
print(fft_max_location1)
fft_max_location2 = np.where(fft_average == secondMax)  # np.where defaults to Y,X,Z
print(fft_max_location2)

# values
kxmax1 = K_grid[fft_max_location1[1]]  # x and y indices are swapped bc np.where
kymax1 = K_grid[fft_max_location1[0]]
kzmax1 = K_grid[fft_max_location1[2]]

kxmax2 = K_grid[fft_max_location2[1]]  # x and y indices are swapped bc np.where
kymax2 = K_grid[fft_max_location2[0]]
kzmax2 = K_grid[fft_max_location2[2]]

# indices
firstIndexX = fft_max_location1[1] #49
firstIndexY = fft_max_location1[0]
firstIndexZ = fft_max_location1[2]

secIndexX = fft_max_location2[1]
secIndexY = fft_max_location2[0]
secIndexZ = fft_max_location2[2]


# Let's plot some stuff

# 1st max - Shifted FFT (slice at specific z)
plt.figure(1)
im1 = plt.contourf(xf[:, :, 10], yf[:, :, 10],
                   fft_signal_shifted[:, :, 10])  # this plots fft at t=22 at z=10 (central freq 39,49,10)
plt.colorbar(im1)
plt.xlabel('x')
plt.ylabel('y')
plt.title('FFT, z = 10')

# 2nd max - Shifted FFT (slice at specific z)
plt.figure(2)
im1 = plt.contourf(xf[:, :, 54], yf[:, :, 54],
                   fft_signal_shifted[:, :, 54])  # this plots fft at t=22 at z=10 (central freq 39,49,10)
plt.colorbar(im1)
plt.xlabel('x')
plt.ylabel('y')
plt.title('FFT, z = 54')

# 1st max - FFT Average (slice at specific z)
plt.figure(3)
im2 = plt.contourf(xf[:, :, 10], yf[:, :, 10], fft_average[:, :, 10]) # correct domain to plot in
plt.colorbar(im2)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Average FFT')

# 2nd max - FFT Average (slice at specific z)
plt.figure(4)
im2 = plt.contourf(xf[:, :, 54], yf[:, :, 54], fft_average[:, :, 54])
plt.colorbar(im2)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Average FFT')

# plot isosurface of FFT Shifted (3D plot)
for j in range(0, 49, 1):
    norm_fft_shifted = np.abs(fft_signal_shifted) / np.abs(fft_signal_shifted).max()
fig_data = go.Isosurface(x=xv.flatten(), y=yv.flatten(), z=zv.flatten(),
                         value=norm_fft_shifted.flatten(), isomin=0.3, isomax=0.7)
clear_output(wait=True)  # need this to discard previous figs
fig = go.Figure(data=fig_data)
fig.update_layout(title='FFT - Shifted')
fig.show(renderer="firefox")
#fig.write_image("/Users/jensen/Downloads/fftshifted.png")

# plot isosurface of average (3D plot)
for j in range(0, 49, 1):
    norm_fft_average = np.abs(fft_average) / np.abs(fft_average).max()
fig_data = go.Isosurface(x=xv.flatten(), y=yv.flatten(), z=zv.flatten(),
                         value=norm_fft_average.flatten(), isomin=0.3, isomax=0.7)
clear_output(wait=True)  # need this to discard previous figs
fig.update_layout(title='FFT - Average')
fig.show(renderer="firefox")


# Task 2: Apply a 3D Gaussian filter (or whatever filter you prefer) in the frequency domain once you
# determine the signature frequency.

# fft converts to fourier domain (frequency) so that you can average it and find the frequency of the submarine... find
# that and then filter so that all we see is that frequency (the one the sub puts out)... then we use ifft will convert
# it back to the time domain

# FILTER - want to keep waves that sub is emitting - this way we can track it in the next task
# set filter up so that it is centered on the submarine frequencies found in Task 1.

def filter(x, y, z, s):  # from lecture 7 code
    # rescale to x, y, z bc index number no real meaning (theoretically, 2L corresponds to some distance in real life)
    centerX = x - ((firstIndexX - 32) * ((2 * L) / 64))  # 49 # this is actually kxmax! (which is just it in kgrid index)
    centerY = y - ((firstIndexY - 32) * ((2 * L) / 64))  # 39 # this is actually kymax!!
    centerZ = z - ((firstIndexZ - 32) * ((2 * L) / 64))  # 10 # this is actually kzmax!!
    oppX = x - ((secIndexX - 32) * ((2 * L) / 64))  # 15
    oppY = y - ((secIndexY - 32) * ((2 * L) / 64))  # 25
    oppZ = z - ((secIndexZ - 32) * ((2 * L) / 64))  # 54

    gauss1 = np.exp(-((centerX ** 2 + centerY ** 2 + centerZ ** 2) / (2 * s ** 2)))
    gauss2 = np.exp(-((oppX ** 2 + oppY ** 2 + oppZ ** 2) / (2 * s ** 2)))
    val = gauss1 + gauss2
    return val


# too small sigma = too much detail to be lost, too big sigma = doesn't remove enough noise
sigma = 2
g_vals = filter(kx, ky, kz, sigma)  # determine filter in frequency domain bc will be applied to fft
shifted_filter = np.fft.fftshift(g_vals);  # apply the shift to the filter

# allocate space for final results
sub_path = np.zeros((49, 3))  # create empty array for sub_path x, y, z coordinates
x_loc = []
y_loc = []
z_loc = []

for j in range(0, 49, 1):
    signal = np.reshape(data[:, j], (N_grid, N_grid, N_grid))
    fft_signal = np.fft.fftn(signal)  # this creates the 3D fourier domain - puts it in freq space
    fft_filtered = fft_signal * shifted_filter  # apply filter to each time step

    # reconstruct the filtered data using ifftn
    denoised = np.real(np.fft.ifftn(fft_filtered))
    denoised_norm = np.abs(denoised) / np.abs(denoised).max()  # normalize it

    # find the maximum
    sub_max = np.amax(denoised)  # this gives us the x,y,z of spatial frequency (1/distance - m^-1?)
    sub_location = np.where(denoised == sub_max)  # np.where defaults to Y,X,Z
    # print(sub_location)

    # FIND CORRESPONDING ENTRY FROM FREQ DOMAIN
    x_loc = np.append(x_loc, x[sub_location[1]])  # x and y indices are swapped in np.where
    y_loc = np.append(y_loc, y[sub_location[0]])
    z_loc = np.append(z_loc, z[sub_location[2]])
    sub_path[j, :] = sub_location  # submarine path in indices

# plot isosurface of filter itself (3D plot)
for j in range(0, 49, 1):
    norm_gvals = np.abs(g_vals) / np.abs(g_vals).max()
fig_data = go.Isosurface(x=xv.flatten(), y=yv.flatten(), z=zv.flatten(),
                         value=norm_gvals.flatten(), isomin=0.3, isomax=0.7)
clear_output(wait=True)  # need this to discard previous figs
fig = go.Figure(data=fig_data)
fig.update_layout(title='Filter')
fig.show(renderer="firefox")
#fig.write_image("/Users/jensen/Downloads/filter.png")

# plot the filter in slices to see what's up at specific z values
plt.figure(5)
im2 = plt.contourf(xf[:, :, 1], yf[:, :, 1], g_vals[:, :, 1])
plt.colorbar(im2)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Gaussian Filter - z = 1')

plt.figure(50)
im2 = plt.contourf(xf[:, :, 63], yf[:, :, 63], g_vals[:, :, 63])
plt.colorbar(im2)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Gaussian Filter - z = 10')

# plot isosurface of the filtered fft (3D plot)
for j in range(0, 49, 1):
    norm_filter = np.abs(fft_filtered) / np.abs(fft_filtered).max()
fig_data = go.Isosurface(x=xv.flatten(), y=yv.flatten(), z=zv.flatten(),
                         value=norm_filter.flatten(), isomin=0.3, isomax=0.7)
clear_output(wait=True)  # need this to discard previous figs
fig = go.Figure(data=fig_data)
fig.update_layout(title='FFT - Filtered')
fig.show(renderer="firefox")
#fig.write_image("/Users/jensen/Downloads/fftfiltered.png")

# plot the filtered fft (slices)
# Probably won't include in report
plt.figure(6)
im2 = plt.contourf(kx[:, :, 10], ky[:, :, 10], fft_filtered[:, :, 10])
plt.colorbar(im2)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Filtered FFT, z = 10')

plt.figure(7)
im2 = plt.contourf(kx[:, :, 54], ky[:, :, 54], fft_filtered[:, :, 54])
plt.colorbar(im2)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Filtered FFT, z =54')

# plot the isosurface denoised data
for j in range(0, 49, 1):
    norm_filter = np.abs(fft_filtered) / np.abs(fft_filtered).max()
fig_data = go.Isosurface(x=xv.flatten(), y=yv.flatten(), z=zv.flatten(),
                         value=denoised_norm.flatten(), isomin=0.3, isomax=0.7)
clear_output(wait=True)  # need this to discard previous figs
fig = go.Figure(data=fig_data)
fig.update_layout(title='Denoised Data')
fig.show(renderer="firefox")
#fig.write_image("/Users/jensen/Downloads/denoised.png")

# plot the ifftn (slices)
plt.figure(8)
im2 = plt.contourf(xf[:, :, 10], yf[:, :, 10],
                   denoised[:, :, 10])  # this plots fft at t=22 at z=10 (central freq 39,49,10)
plt.colorbar(im2)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Denoised IFFT Reconstruction')

plt.figure(9)
im2 = plt.contourf(xf[:, :, 54], yf[:, :, 54], denoised[:, :, 54])
plt.colorbar(im2)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Denoised IFFT Reconstruction')

# Task 3 Deliverables - need the x,y 2D graph or a table with the 2D coordinates
# should be on the -10 to 10 grid
# plot the submarine path (3D)
fig2 = plt.figure()
ax = plt.axes(projection='3d')
ax.plot3D(x_loc, y_loc, z_loc, 'red')
ax.axes.set_xlim3d(left=-10, right=10)  # -10 to 10 is the frequency domain
ax.axes.set_ylim3d(bottom=-10, top=10)
ax.axes.set_zlim3d(bottom=-10, top=10)
plt.title('X,Y,Z Coordinates of Submarine for 24 Hour Period')
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_zlabel('z')

# plot the submarine path (2D)
fig3, ax = plt.subplots()
ax.plot(x_loc, y_loc)
ax.axes.set_xlim(left=-10, right=10)
ax.axes.set_ylim(bottom=-10, top=10)
plt.title('X,Y Coordinates of Submarine for 24 Hour Period')
ax.set_xlabel('x')
ax.set_ylabel('y')
